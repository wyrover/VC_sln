#ifndef _ROVERLIB_REGISTRYUTILS_H_
#define _ROVERLIB_REGISTRYUTILS_H_

namespace roverlib
{

	class RegistryUtils
	{	
	public:
		//// Call this function with Rootkey name and filename. This enumerates through the keys 
		//// and subkeys and stores all its values.
		void ExportRegistry(CString cstrKeyRootName, CString cstrKeyName, CString cstrFileName);

		//使用ShellExecute方式导入导出注册表项
		void ShellExportRegister(LPCTSTR lpExportStr,LPCTSTR lpExportFile);
		void ShellImportRegister(LPCTSTR lpImportFile);

	private:
		//Enumerate through all the sub key of a given key
		void EnumerateKey(HKEY hKey,CString strKey, FILE *fp, CString cstrFullPath);

		//Enumerate through all the values of a given key
		void EnumerateValues(HKEY hKey, CString cstrKey, FILE *fp, CString cstrFullPath);

		//To format the data with datatype as in .EXP file generated by REGEDIT....
		void FormatDataWithDataType(DWORD dwKeyType, LPBYTE pbbinKeyData, DWORD dwKeyDataLength, CString &cstrOutput);

		BOOL IsSubKey(HKEY hKey,LPCTSTR lpSubKey);
		BOOL IsExist(HKEY hKey,LPCTSTR lpSubKey);
	};
}

namespace roverlib
{
	inline void RegistryUtils::ExportRegistry(CString cstrKeyRootName, CString cstrKeyName, CString cstrFileName)
	{
		FILE *fp;
		HKEY hKeyRootName;
		CString cstrFullPathStr(_T(""));

		if(cstrKeyRootName == _T("HKEY_CLASSES_ROOT"))
			hKeyRootName = HKEY_CLASSES_ROOT;
		else if(cstrKeyRootName == _T("HKEY_CURRENT_USER"))
			hKeyRootName = HKEY_CURRENT_USER;
		else if(cstrKeyRootName == _T("HKEY_LOCAL_MACHINE"))
			hKeyRootName = HKEY_LOCAL_MACHINE;
		else if(cstrKeyRootName == _T("HKEY_USERS"))
			hKeyRootName = HKEY_USERS;
		else if(cstrKeyRootName == _T("HKEY_PERFORMANCE_DATA"))
			hKeyRootName = HKEY_PERFORMANCE_DATA;
		else if(cstrKeyRootName == _T("HKEY_CURRENT_CONFIG"))
			hKeyRootName = HKEY_CURRENT_CONFIG;
		else if(cstrKeyRootName == _T("HKEY_DYN_DATA"))
			hKeyRootName = HKEY_DYN_DATA;

		
		fp = _wfopen(cstrFileName, L"w+");
		if (fp == NULL)
		{
			MessageBox(NULL, _T("Error while creating the file"), _T("Registry export"), MB_OK);
			return;
		}

		if(cstrKeyName.IsEmpty())
			cstrFullPathStr = cstrKeyRootName;
		else
			cstrFullPathStr = cstrKeyRootName + _T("\\") + cstrKeyName;

		//// First print the header ..... this may be different for some version of Windows... do manually change if required
		//Here need to add version check
		DWORD dwVersion = GetVersion();
		// Get build numbers for Windows NT or Win32s
		if (dwVersion < 0x80000000)                // Windows NT
		{
			_ftprintf(fp, _T("%s\n"), _T("Windows Registry Editor Version 5.00"));
		}
		else        // Win32s
		{
			_ftprintf(fp, _T("%s\n"), _T("REGEDIT4"));
		}

		EnumerateValues(hKeyRootName, cstrKeyName, fp, cstrFullPathStr);
		EnumerateKey(hKeyRootName, cstrKeyName , fp , cstrFullPathStr);
		fclose(fp);
	}

	inline void RegistryUtils::EnumerateValues(HKEY hKey, CString cstrKey, FILE *fp, CString cstrFullPath)
	{
		static HKEY hLastKey = hKey;
		LONG lResult;
		DWORD dwIndex = 0;
		HKEY hCurKey = hKey;
		DWORD dwKeyType; 
		DWORD dwKeyDataLength, dwKeyNameLen;
		LPBYTE pbbinKeyData = NULL; 
		TCHAR *tcKeyName = NULL;
		TCHAR tcDataType[1024] = _T("");

		lResult = RegOpenKeyEx(hCurKey, cstrKey, 0, KEY_QUERY_VALUE , &hKey);
		if(lResult != ERROR_SUCCESS)
			return;

		DWORD lNoOfValues = 0;
		DWORD lLongestKeyNameLen = 1;
		DWORD lLongestDataLen = 1;

		lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &lNoOfValues, &lLongestKeyNameLen, &lLongestDataLen,
			NULL, NULL);

		if(lResult != ERROR_SUCCESS)
			return;

		_ftprintf(fp, _T("\n[%s]\n"), cstrFullPath);

		hLastKey = hKey;

		lLongestKeyNameLen++;
		lLongestDataLen++;

		tcKeyName =	new TCHAR[lLongestKeyNameLen];
		pbbinKeyData = new BYTE[lLongestDataLen];

		CString cstrFinalData, cstrTemp;

		while(TRUE)
		{
			memset(pbbinKeyData, 0, lLongestDataLen);
			memset(tcKeyName, 0, lLongestKeyNameLen);
			dwKeyType = dwKeyDataLength = dwKeyNameLen = 0;

			dwKeyNameLen = lLongestKeyNameLen;
			dwKeyDataLength = lLongestDataLen;

			lResult = RegEnumValue(hKey, dwIndex, tcKeyName, &dwKeyNameLen, NULL, &dwKeyType, pbbinKeyData, &dwKeyDataLength);
			if(lResult == ERROR_NO_MORE_ITEMS)
				break;

			FormatDataWithDataType(dwKeyType, pbbinKeyData, dwKeyDataLength, cstrFinalData);

			//// For (default) key names the tcKeyName is empty and dwKeyNameLen is zero ...in such case we need to 
			//// have assignment like @ = "value"
			CString cstrTest;
			cstrTest = tcKeyName;
			if(cstrTest.IsEmpty())
			{
				cstrTemp.Format(_T("@="));
			}
			else
			{
				cstrTemp.Format(_T("\"%s\"="), tcKeyName);
			}
			cstrTemp += cstrFinalData;

			_ftprintf(fp, _T("%s"), (LPCTSTR)cstrTemp);
			dwIndex++;
		}
		RegCloseKey(hKey);
		delete tcKeyName;
		delete[] pbbinKeyData;
	}


	inline void RegistryUtils::FormatDataWithDataType(DWORD dwKeyType, LPBYTE pbbinKeyData, DWORD dwKeyDataLength, CString &cstrOutput)	
	{
		CString cstrTemp, cstrTemp1 ,cstrTemp2;
		int nIndex = 0;
		switch(dwKeyType)
		{
		case REG_SZ:
			{
				cstrTemp.Format(_T("\"%s\"\n"), pbbinKeyData);
				for(int i=0;i<cstrTemp.GetLength();i++)
				{
					cstrTemp1 = cstrTemp.Mid(i,1); 
					if(cstrTemp.Mid(i,1) == "\\")
					{
						cstrTemp1 = cstrTemp.Left(i); 
						cstrTemp2 = cstrTemp.Right(cstrTemp.GetLength()-i-1);
						cstrTemp = cstrTemp1 + _T("\\\\") + cstrTemp2;
						i++;
					}				

				}
				cstrOutput = cstrTemp;
				break;
			}

		case REG_DWORD: /// same is for REG_DWORD_LITTLE_ENDIAN
			{
				DWORD dwValue;
				memcpy(&dwValue, pbbinKeyData, sizeof DWORD);
				cstrTemp.Format(_T("dword:%08x\n"), dwValue);
				cstrOutput = cstrTemp;
				break;
			}

		case REG_BINARY:
		case REG_MULTI_SZ:
		case REG_EXPAND_SZ:
		case REG_FULL_RESOURCE_DESCRIPTOR:
		case REG_RESOURCE_LIST:
		case REG_RESOURCE_REQUIREMENTS_LIST:
			{
				if(dwKeyType != REG_BINARY)
					cstrOutput.Format(_T("hex(%d):"), dwKeyType);
				else
					cstrOutput.Format(_T("hex:"));

				for(DWORD dwIndex = 0; dwIndex < dwKeyDataLength; dwIndex++)
				{
					cstrTemp1.Format(_T("%02x"), pbbinKeyData[dwIndex]);
					if(dwIndex != 0 && (dwIndex % 0x15 == 0))
					{
						cstrTemp += _T(",\\\n");
						cstrTemp += cstrTemp1;
					}
					else
					{
						if( cstrTemp.IsEmpty() )
							cstrTemp = cstrTemp1;
						else
							cstrTemp += _T(",")+cstrTemp1;
					}
				}

				cstrTemp += _T("\n");
				cstrOutput += cstrTemp;
				break;
			}

		case REG_NONE:
		case REG_DWORD_BIG_ENDIAN:
		case REG_LINK:
			//// TODO : add code for these types...
			break;

		}
	}


	inline BOOL RegistryUtils::IsExist(HKEY hKey,LPCTSTR lpSubKey)
	{
		HKEY phkResult;
		if( ERROR_SUCCESS == RegOpenKeyEx(hKey,lpSubKey,0,
			KEY_EXECUTE,&phkResult))
		{
			RegCloseKey(phkResult);
			return TRUE;
		}
		return FALSE;
	}

	inline BOOL RegistryUtils::IsSubKey(HKEY hKey,LPCTSTR lpSubKey)
	{
		if(IsExist(hKey,lpSubKey))
		{
			HKEY phkResult;
			if( ERROR_SUCCESS == RegOpenKeyEx(hKey,lpSubKey,0,
				KEY_READ,&phkResult))
			{
				TCHAR sz[MAX_PATH];
				if( ERROR_SUCCESS == RegEnumKey(phkResult,0,sz,MAX_PATH))
				{
					RegCloseKey(phkResult);
					return TRUE;
				}
				RegCloseKey(phkResult);
			}
		}
		return FALSE;
	}

	inline void RegistryUtils::EnumerateKey(HKEY hKey,CString strKey, FILE *fp,CString cstrFullPath)
	{
		TCHAR strCurString[1024];
		long lResult;
		DWORD dwCurIndex = 0;
		HKEY hCurKey;
		CString currentKey;
		CString subKey = strKey;
		CString fullKey = cstrFullPath;

		//// first open the root key to get the handle...
		lResult = RegOpenKeyEx(hKey, strKey, 0, KEY_ENUMERATE_SUB_KEYS, &hCurKey);
		if( lResult != ERROR_SUCCESS )
			return;

		do
		{
			lResult = RegEnumKey(hCurKey, dwCurIndex, strCurString , sizeof(strCurString));

			if((lResult == ERROR_NO_MORE_ITEMS) || (lResult == ERROR_INVALID_HANDLE))
			{
				break;
			}
			else
			{
				currentKey.Format(_T("%s"), strCurString);
				if(currentKey.IsEmpty())
					fullKey = cstrFullPath;
				else
				{
					fullKey = cstrFullPath + _T("\\") + currentKey;
					subKey  = strKey + _T("\\") + strCurString;
				}
				EnumerateValues(hKey, subKey , fp, fullKey);
				if(IsSubKey(hKey , subKey))
				{				
					EnumerateKey(hKey , subKey , fp, fullKey);
				}
				dwCurIndex++;
			}

		}while(TRUE);
		RegCloseKey(hCurKey);
	}


	inline void RegistryUtils::ShellExportRegister(LPCTSTR lpExportStr,LPCTSTR lpExportFile)
	{
		CString strItem(lpExportStr);
		CString strFileName(lpExportFile);
		CString strFilePath;
		CString strParameters;
		int nIndex = 0;

		strParameters = _T("/e \"") + strFileName + _T("\" \"") + strItem + _T("\"");
		ShellExecute(0, _T("open"), _T("regedit.exe"),
			strParameters, NULL	, SW_SHOWNORMAL);
	}

	inline void RegistryUtils::ShellImportRegister(LPCTSTR lpImportFile)
	{
		CString strItem(lpImportFile);
		CString strParameters;

		strParameters = _T("/s \"") + strItem + _T("\"");
		ShellExecute(NULL, _T("open"), _T("regedit.exe"), strParameters, NULL, SW_HIDE);
	}



	static bool GetKeyValue(const WCHAR *keyLocation, const WCHAR *keyName, std
		::wstring &destString, int type)
	{
		HKEY key;
		DWORD dwcbData;
		DWORD dValue;
		DWORD resultType;
		LONG result;
		bool retval = true;

		result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyLocation, 0, KEY_QUERY_VALUE,
			&key);
		if (result != ERROR_SUCCESS)
		{
			return false;
		}

		switch (type)
		{
		case REG_DWORD:
			{
				// We only use this for vram size
				dwcbData = sizeof(dValue);
				result = RegQueryValueExW(key, keyName, NULL, &resultType,
					(LPBYTE) &dValue, &dwcbData);
				if (result == ERROR_SUCCESS && resultType == REG_DWORD)
				{
					dValue = dValue / 1024 / 1024;					
					WCHAR msg[1024] = {0};
					_snwprintf(msg, 1024, L"%s", dValue);
					destString.append(msg);
				}
				else
				{
					retval = false;
				}
				break;
			}
		case REG_MULTI_SZ:
			{
				// A chain of null-separated strings; we convert the nulls to spaces
				WCHAR wCharValue[1024];
				dwcbData = sizeof(wCharValue);

				result = RegQueryValueExW(key, keyName, NULL, &resultType,
					(LPBYTE)wCharValue, &dwcbData);
				if (result == ERROR_SUCCESS && resultType == REG_MULTI_SZ)
				{
					// This bit here could probably be cleaner.
					bool isValid = false;

					DWORD strLen = dwcbData / sizeof(wCharValue[0]);
					for (DWORD i = 0; i < strLen; i++)
					{
						if (wCharValue[i] == '\0')
						{
							if (i < strLen - 1 && wCharValue[i + 1] == '\0')
							{
								isValid = true;
								break;
							}
							else
							{
								wCharValue[i] = ' ';
							}
						}
					}

					// ensure wCharValue is null terminated
					wCharValue[strLen - 1] = '\0';

					if (isValid)
						destString.append(wCharValue);

				}
				else
				{
					retval = false;
				}

				break;
			}
		}
		RegCloseKey(key);

		return retval;
	}




	inline bool GetFirefoxDirFromRegistry(char *firefoxDir)
	{
		HKEY key;
		wchar_t wideGreDir[MAX_PATH+1] = {0};

		if (ERROR_SUCCESS != RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows"
			L"\\CurrentVersion\\App paths\\firefox.exe", 0, KEY_READ,  &key))
		{
			return false;
		}

		DWORD length = MAX_PATH * sizeof(wchar_t);
		// XXX: When Vista/XP64 become our minimum supported client, we can use
		//      RegGetValue instead
		if (ERROR_SUCCESS != RegQueryValueExW(key, L"Path", NULL, NULL,
			reinterpret_cast < BYTE * > (wideGreDir),  &length))
		{
			RegCloseKey(key);
			return false;
		};
		RegCloseKey(key);

		// According to this article, we need to write our own null terminator:
		// http://msdn.microsoft.com/en-us/library/ms724911%28v=vs.85%29.aspx
		length = length / sizeof(wchar_t);
		if (wideGreDir[length] != L'\0')
		{
			if (length >= MAX_PATH)
			{
				return false;
			}
			wideGreDir[length] = L'\0';
		}

		if (0 == WideCharToMultiByte(CP_UTF8, 0, wideGreDir,  - 1, firefoxDir,
			MAX_PATH, NULL, NULL))
		{
			return false;
		}

		return true;
	}


}


#endif // #ifndef _ROVERLIB_REGISTRYUTILS_H_
