#ifndef _ROVERLIB_REGISTRYUTILS_H_
#define _ROVERLIB_REGISTRYUTILS_H_

namespace roverlib
{

	class RegistryUtils
	{	
	public:
		//// Call this function with Rootkey name and filename. This enumerates through the keys 
		//// and subkeys and stores all its values.
		void ExportRegistry(CString cstrKeyRootName, CString cstrKeyName, CString cstrFileName);

		//使用ShellExecute方式导入导出注册表项
		void ShellExportRegister(LPCTSTR lpExportStr,LPCTSTR lpExportFile);
		void ShellImportRegister(LPCTSTR lpImportFile);

	private:
		//Enumerate through all the sub key of a given key
		void EnumerateKey(HKEY hKey,CString strKey, FILE *fp, CString cstrFullPath);

		//Enumerate through all the values of a given key
		void EnumerateValues(HKEY hKey, CString cstrKey, FILE *fp, CString cstrFullPath);

		//To format the data with datatype as in .EXP file generated by REGEDIT....
		void FormatDataWithDataType(DWORD dwKeyType, LPBYTE pbbinKeyData, DWORD dwKeyDataLength, CString &cstrOutput);

		BOOL IsSubKey(HKEY hKey,LPCTSTR lpSubKey);
		BOOL IsExist(HKEY hKey,LPCTSTR lpSubKey);
	};
}

namespace roverlib
{
	inline void RegistryUtils::ExportRegistry(CString cstrKeyRootName, CString cstrKeyName, CString cstrFileName)
	{
		FILE *fp;
		HKEY hKeyRootName;
		CString cstrFullPathStr(_T(""));

		if(cstrKeyRootName == _T("HKEY_CLASSES_ROOT"))
			hKeyRootName = HKEY_CLASSES_ROOT;
		else if(cstrKeyRootName == _T("HKEY_CURRENT_USER"))
			hKeyRootName = HKEY_CURRENT_USER;
		else if(cstrKeyRootName == _T("HKEY_LOCAL_MACHINE"))
			hKeyRootName = HKEY_LOCAL_MACHINE;
		else if(cstrKeyRootName == _T("HKEY_USERS"))
			hKeyRootName = HKEY_USERS;
		else if(cstrKeyRootName == _T("HKEY_PERFORMANCE_DATA"))
			hKeyRootName = HKEY_PERFORMANCE_DATA;
		else if(cstrKeyRootName == _T("HKEY_CURRENT_CONFIG"))
			hKeyRootName = HKEY_CURRENT_CONFIG;
		else if(cstrKeyRootName == _T("HKEY_DYN_DATA"))
			hKeyRootName = HKEY_DYN_DATA;

		
		fp = _wfopen(cstrFileName, L"w+");
		if (fp == NULL)
		{
			MessageBox(NULL, _T("Error while creating the file"), _T("Registry export"), MB_OK);
			return;
		}

		if(cstrKeyName.IsEmpty())
			cstrFullPathStr = cstrKeyRootName;
		else
			cstrFullPathStr = cstrKeyRootName + _T("\\") + cstrKeyName;

		//// First print the header ..... this may be different for some version of Windows... do manually change if required
		//Here need to add version check
		DWORD dwVersion = GetVersion();
		// Get build numbers for Windows NT or Win32s
		if (dwVersion < 0x80000000)                // Windows NT
		{
			_ftprintf(fp, _T("%s\n"), _T("Windows Registry Editor Version 5.00"));
		}
		else        // Win32s
		{
			_ftprintf(fp, _T("%s\n"), _T("REGEDIT4"));
		}

		EnumerateValues(hKeyRootName, cstrKeyName, fp, cstrFullPathStr);
		EnumerateKey(hKeyRootName, cstrKeyName , fp , cstrFullPathStr);
		fclose(fp);
	}

	inline void RegistryUtils::EnumerateValues(HKEY hKey, CString cstrKey, FILE *fp, CString cstrFullPath)
	{
		static HKEY hLastKey = hKey;
		LONG lResult;
		DWORD dwIndex = 0;
		HKEY hCurKey = hKey;
		DWORD dwKeyType; 
		DWORD dwKeyDataLength, dwKeyNameLen;
		LPBYTE pbbinKeyData = NULL; 
		TCHAR *tcKeyName = NULL;
		TCHAR tcDataType[1024] = _T("");

		lResult = RegOpenKeyEx(hCurKey, cstrKey, 0, KEY_QUERY_VALUE , &hKey);
		if(lResult != ERROR_SUCCESS)
			return;

		DWORD lNoOfValues = 0;
		DWORD lLongestKeyNameLen = 1;
		DWORD lLongestDataLen = 1;

		lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &lNoOfValues, &lLongestKeyNameLen, &lLongestDataLen,
			NULL, NULL);

		if(lResult != ERROR_SUCCESS)
			return;

		_ftprintf(fp, _T("\n[%s]\n"), cstrFullPath);

		hLastKey = hKey;

		lLongestKeyNameLen++;
		lLongestDataLen++;

		tcKeyName =	new TCHAR[lLongestKeyNameLen];
		pbbinKeyData = new BYTE[lLongestDataLen];

		CString cstrFinalData, cstrTemp;

		while(TRUE)
		{
			memset(pbbinKeyData, 0, lLongestDataLen);
			memset(tcKeyName, 0, lLongestKeyNameLen);
			dwKeyType = dwKeyDataLength = dwKeyNameLen = 0;

			dwKeyNameLen = lLongestKeyNameLen;
			dwKeyDataLength = lLongestDataLen;

			lResult = RegEnumValue(hKey, dwIndex, tcKeyName, &dwKeyNameLen, NULL, &dwKeyType, pbbinKeyData, &dwKeyDataLength);
			if(lResult == ERROR_NO_MORE_ITEMS)
				break;

			FormatDataWithDataType(dwKeyType, pbbinKeyData, dwKeyDataLength, cstrFinalData);

			//// For (default) key names the tcKeyName is empty and dwKeyNameLen is zero ...in such case we need to 
			//// have assignment like @ = "value"
			CString cstrTest;
			cstrTest = tcKeyName;
			if(cstrTest.IsEmpty())
			{
				cstrTemp.Format(_T("@="));
			}
			else
			{
				cstrTemp.Format(_T("\"%s\"="), tcKeyName);
			}
			cstrTemp += cstrFinalData;

			_ftprintf(fp, _T("%s"), (LPCTSTR)cstrTemp);
			dwIndex++;
		}
		RegCloseKey(hKey);
		delete tcKeyName;
		delete pbbinKeyData;
	}


	inline void RegistryUtils::FormatDataWithDataType(DWORD dwKeyType, LPBYTE pbbinKeyData, DWORD dwKeyDataLength, CString &cstrOutput)	
	{
		CString cstrTemp, cstrTemp1 ,cstrTemp2;
		int nIndex = 0;
		switch(dwKeyType)
		{
		case REG_SZ:
			{
				cstrTemp.Format(_T("\"%s\"\n"), pbbinKeyData);
				for(int i=0;i<cstrTemp.GetLength();i++)
				{
					cstrTemp1 = cstrTemp.Mid(i,1); 
					if(cstrTemp.Mid(i,1) == "\\")
					{
						cstrTemp1 = cstrTemp.Left(i); 
						cstrTemp2 = cstrTemp.Right(cstrTemp.GetLength()-i-1);
						cstrTemp = cstrTemp1 + _T("\\\\") + cstrTemp2;
						i++;
					}				

				}
				cstrOutput = cstrTemp;
				break;
			}

		case REG_DWORD: /// same is for REG_DWORD_LITTLE_ENDIAN
			{
				DWORD dwValue;
				memcpy(&dwValue, pbbinKeyData, sizeof DWORD);
				cstrTemp.Format(_T("dword:%08x\n"), dwValue);
				cstrOutput = cstrTemp;
				break;
			}

		case REG_BINARY:
		case REG_MULTI_SZ:
		case REG_EXPAND_SZ:
		case REG_FULL_RESOURCE_DESCRIPTOR:
		case REG_RESOURCE_LIST:
		case REG_RESOURCE_REQUIREMENTS_LIST:
			{
				if(dwKeyType != REG_BINARY)
					cstrOutput.Format(_T("hex(%d):"), dwKeyType);
				else
					cstrOutput.Format(_T("hex:"));

				for(DWORD dwIndex = 0; dwIndex < dwKeyDataLength; dwIndex++)
				{
					cstrTemp1.Format(_T("%02x"), pbbinKeyData[dwIndex]);
					if(dwIndex != 0 && (dwIndex % 0x15 == 0))
					{
						cstrTemp += _T(",\\\n");
						cstrTemp += cstrTemp1;
					}
					else
					{
						if( cstrTemp.IsEmpty() )
							cstrTemp = cstrTemp1;
						else
							cstrTemp += _T(",")+cstrTemp1;
					}
				}

				cstrTemp += _T("\n");
				cstrOutput += cstrTemp;
				break;
			}

		case REG_NONE:
		case REG_DWORD_BIG_ENDIAN:
		case REG_LINK:
			//// TODO : add code for these types...
			break;

		}
	}


	inline BOOL RegistryUtils::IsExist(HKEY hKey,LPCTSTR lpSubKey)
	{
		HKEY phkResult;
		if( ERROR_SUCCESS == RegOpenKeyEx(hKey,lpSubKey,0,
			KEY_EXECUTE,&phkResult))
		{
			RegCloseKey(phkResult);
			return TRUE;
		}
		return FALSE;
	}

	inline BOOL RegistryUtils::IsSubKey(HKEY hKey,LPCTSTR lpSubKey)
	{
		if(IsExist(hKey,lpSubKey))
		{
			HKEY phkResult;
			if( ERROR_SUCCESS == RegOpenKeyEx(hKey,lpSubKey,0,
				KEY_READ,&phkResult))
			{
				TCHAR sz[MAX_PATH];
				if( ERROR_SUCCESS == RegEnumKey(phkResult,0,sz,MAX_PATH))
				{
					RegCloseKey(phkResult);
					return TRUE;
				}
				RegCloseKey(phkResult);
			}
		}
		return FALSE;
	}

	inline void RegistryUtils::EnumerateKey(HKEY hKey,CString strKey, FILE *fp,CString cstrFullPath)
	{
		TCHAR strCurString[1024];
		long lResult;
		DWORD dwCurIndex = 0;
		HKEY hCurKey;
		CString currentKey;
		CString subKey = strKey;
		CString fullKey = cstrFullPath;

		//// first open the root key to get the handle...
		lResult = RegOpenKeyEx(hKey, strKey, 0, KEY_ENUMERATE_SUB_KEYS, &hCurKey);
		if( lResult != ERROR_SUCCESS )
			return;

		do
		{
			lResult = RegEnumKey(hCurKey, dwCurIndex, strCurString , sizeof(strCurString));

			if((lResult == ERROR_NO_MORE_ITEMS) || (lResult == ERROR_INVALID_HANDLE))
			{
				break;
			}
			else
			{
				currentKey.Format(_T("%s"), strCurString);
				if(currentKey.IsEmpty())
					fullKey = cstrFullPath;
				else
				{
					fullKey = cstrFullPath + _T("\\") + currentKey;
					subKey  = strKey + _T("\\") + strCurString;
				}
				EnumerateValues(hKey, subKey , fp, fullKey);
				if(IsSubKey(hKey , subKey))
				{				
					EnumerateKey(hKey , subKey , fp, fullKey);
				}
				dwCurIndex++;
			}

		}while(TRUE);
		RegCloseKey(hCurKey);
	}


	inline void RegistryUtils::ShellExportRegister(LPCTSTR lpExportStr,LPCTSTR lpExportFile)
	{
		CString strItem(lpExportStr);
		CString strFileName(lpExportFile);
		CString strFilePath;
		CString strParameters;
		int nIndex = 0;

		strParameters = _T("/e \"") + strFileName + _T("\" \"") + strItem + _T("\"");
		ShellExecute(0, _T("open"), _T("regedit.exe"),
			strParameters, NULL	, SW_SHOWNORMAL);
	}

	inline void RegistryUtils::ShellImportRegister(LPCTSTR lpImportFile)
	{
		CString strItem(lpImportFile);
		CString strParameters;

		strParameters = _T("/s \"") + strItem + _T("\"");
		ShellExecute(NULL, _T("open"), _T("regedit.exe"), strParameters, NULL, SW_HIDE);
	}

}


#endif // #ifndef _ROVERLIB_REGISTRYUTILS_H_
